<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATProto Self-Sovereign Account Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            background: #0a0a0a;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 162, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(138, 43, 226, 0.1) 0%, transparent 50%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: #1a1a1a;
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 40px;
            max-width: 1200px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
            
            letter-spacing: 2px;
        }

        .subtitle {
            color: #a0a0a0;
            margin-bottom: 30px;
            font-size: 1.1em;
            font-weight: 400;
        }

        .key-display {
            background: #0f0f0f;
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00ff88;
            
        }

        .key-display.has-key {
            background: #0f1f1a;
            border-color: #00ff88;
            color: #00ff88;
            
        }

        .generate-btn {
            background: #0a0a0a;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .generate-btn:hover {
            background: #00ff88;
            color: #0a0a0a;
            
            transform: translateY(-2px);
        }

        .generate-btn:active {
            transform: translateY(0);
        }

        .copy-btn {
            background: #0a0a0a;
            color: #00a2ff;
            border: 1px solid #00a2ff;
            padding: 10px 20px;
            font-size: 0.9em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .copy-btn:hover {
            background: #00a2ff;
            color: #0a0a0a;
            
            transform: translateY(-1px);
        }

        .copy-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .mnemonic-display {
            background: #0f0f0f;
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
            
        }

        .mnemonic-display h3 {
            color: #00ff88;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.2em;
            
            letter-spacing: 2px;
        }

        .mnemonic-text {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            line-height: 1.8;
            color: #00ff88;
            word-break: break-word;
            background: #0a0a0a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #00ff88;
            
        }

        .public-key-display {
            background: #f0f8f0;
            border: 2px dashed #28a745;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .public-key-display h3 {
            color: #155724;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.2em;
        }

        .public-key-text {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #155724;
            word-break: break-all;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #c3e6cb;
        }

        .did-key-display {
            background: #0f0f0f;
            border: 1px solid #00ff88;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
            
        }

        .did-key-display h3 {
            color: #00ff88;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.2em;
            
            letter-spacing: 2px;
        }

        .did-key-text {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            color: #00ff88;
            word-break: break-all;
            background: #0a0a0a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #00ff88;
            
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .restore-section {
            background: #0f0f0f;
            border: 1px solid #00a2ff;
            border-radius: 4px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            
        }

        .restore-section h3 {
            color: #00a2ff;
            margin-bottom: 10px;
            font-size: 1.2em;
            
            letter-spacing: 2px;
        }

        .restore-subtitle {
            color: #a0a0a0;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .mnemonic-input-container {
            margin: 15px 0;
        }

        .mnemonic-input-container textarea {
            width: 100%;
            max-width: 600px;
            padding: 15px;
            border: 1px solid #00a2ff;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: vertical;
            background: #0a0a0a;
            color: #00a2ff;
            
        }

        .mnemonic-input-container textarea:focus {
            outline: none;
            border-color: #00ff88;
            
        }

        .restore-button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .restore-btn {
            background: #0a0a0a;
            color: #00a2ff;
            border: 1px solid #00a2ff;
            padding: 12px 24px;
            font-size: 1em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .restore-btn:hover {
            background: #00a2ff;
            color: #0a0a0a;
            
            transform: translateY(-1px);
        }

        .restore-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            
        }

        .clear-btn {
            background: #0a0a0a;
            color: #ff4444;
            border: 1px solid #ff4444;
            padding: 12px 24px;
            font-size: 1em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .clear-btn:hover {
            background: #ff4444;
            color: #0a0a0a;
            
            transform: translateY(-1px);
        }

        .key-generation-section {
            display: block;
        }

        .clear-key-section {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        .info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: left;
        }

        .info h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .info p {
            color: #424242;
            line-height: 1.6;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            font-weight: 500;
        }

        .status.success {
            background: #0f1f1a;
            color: #00ff88;
            border: 1px solid #00ff88;
            
        }

        .status.error {
            background: #1f0f0f;
            color: #ff4444;
            border: 1px solid #ff4444;
            
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            justify-content: center;
            margin: 30px 0 20px 0;
            border-bottom: 2px solid #00ff88;
        }

        .tab-btn {
            background: #0a0a0a;
            border: 1px solid #00ff88;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 700;
            color: #00ff88;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            margin: 0 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .tab-btn:hover {
            color: #0a0a0a;
            background: #00ff88;
            
        }

        .tab-btn.active {
            color: #0a0a0a;
            background: #00ff88;
            border-bottom-color: #00ff88;
            
        }

        .tab-btn.inactive {
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            
            opacity: 0.5;
        }

        .tab-btn.inactive:hover {
            color: #555;
            background: #0a0a0a;
            
        }

        .tab-content {
            position: relative;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        /* DID:PLC Form Styles */
        .plc-form-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .plc-form-container h2 {
            color: #00ff88;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8em;
            
            letter-spacing: 2px;
        }

        .plc-subtitle {
            text-align: center;
            color: #a0a0a0;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .plc-form {
            background: #0f0f0f;
            padding: 30px;
            border-radius: 4px;
            border: 1px solid #00ff88;
            
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            font-weight: 700;
            color: #00ff88;
            margin-bottom: 8px;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #00ff88;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
            box-sizing: border-box;
            background: #0a0a0a;
            color: #00ff88;
            
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #00a2ff;
            
        }

        .did-input-group {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        .did-input-group input {
            flex: 1;
        }

        .did-button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .fetch-btn {
            background: #0a0a0a;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 12px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .fetch-btn:hover {
            background: #00ff88;
            color: #0a0a0a;
            
            transform: translateY(-1px);
        }

        .fetch-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            
        }

        .verify-btn {
            background: #0a0a0a;
            color: #00a2ff;
            border: 1px solid #00a2ff;
            padding: 12px 20px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .verify-btn:hover {
            background: #00a2ff;
            color: #0a0a0a;
            
            transform: translateY(-1px);
        }

        .verify-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            
        }

        .verification-results {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .verification-results h4 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 18px;
        }

        .verification-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .verification-item code {
            background: #f1f3f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #d63384;
        }
        
        .rotation-key-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .rotation-key-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .remove-rotation-key-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .remove-rotation-key-btn:hover {
            background: #c82333;
        }
        
        #add-rotation-key-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 5px;
        }
        
        #add-rotation-key-btn:hover {
            background: #218838;
        }
        
        .also-known-as-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .also-known-as-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .remove-also-known-as-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .remove-also-known-as-btn:hover {
            background: #c82333;
        }
        
        #add-also-known-as-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 5px;
        }
        
        #add-also-known-as-btn:hover {
            background: #218838;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #007bff;
            
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-help {
            display: block;
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 5px;
            font-style: italic;
        }

        .form-button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .submit-btn {
            background: #0a0a0a;
            color: #00ff88;
            border: 1px solid #00ff88;
            padding: 15px 30px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            
        }

        .submit-btn:hover {
            background: #00ff88;
            color: #0a0a0a;
            
            transform: translateY(-2px);
        }

        .submit-btn:disabled {
            background: #1a1a1a;
            color: #555;
            border-color: #555;
            cursor: not-allowed;
            
            opacity: 0.5;
        }

        .submit-btn:disabled:hover {
            transform: none;
            
        }

        .plc-result {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            text-align: center;
        }

        .plc-result h3 {
            color: #155724;
            margin-bottom: 15px;
        }

        .plc-result-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #c3e6cb;
            margin-bottom: 15px;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 300px;
            overflow-y: auto;
        }

        .plc-debug {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            text-align: center;
        }

        .plc-debug h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .plc-debug-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ffeaa7;
            margin-bottom: 15px;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ATProto Self-Sovereign Account Creator</h1>
        <p class="subtitle"></p>
        
        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" id="keygen-tab" data-tab="keygen">
                Key
            </button>
            <button class="tab-btn" id="createaccount-tab" data-tab="createaccount">
                Account
            </button>
            <button class="tab-btn" id="didplc-tab" data-tab="didplc">
                Custom
            </button>
        </div>
        
        <!-- Tab Content -->
        <div class="tab-content">
            <!-- Key Generation Tab -->
            <div class="tab-pane active" id="keygen-pane">
        
 
        <div class="did-key-display" id="didKeyDisplay" style="display: none;">
            <h3>DECENTRALIZED IDENTIFIER</h3>
            <div class="did-key-text" id="didKeyText"></div>
        </div>


        <!--
        <div class="key-display" id="keyDisplay">
            Click "Generate Key" to create a new private key
        </div>
        -->
        
        <div class="mnemonic-display" id="mnemonicDisplay" style="display: none;">
            <h3>MNEMONIC SEED PHRASE</h3>
            <div class="mnemonic-text" id="mnemonicText"></div>
        </div>
        
        <!--
        <div class="public-key-display" id="publicKeyDisplay" style="display: none;">
            <h3>secp256k1 Public Key</h3>
            <div class="public-key-text" id="publicKeyText"></div>
        </div>
        -->
               
        <div class="key-generation-section" id="keyGenerationSection">
            <div class="button-group">
                <button class="generate-btn" id="generateBtn">
                    GENERATE KEY
                </button>
                
                <!--
                <button class="copy-btn" id="copyBtn" disabled>
                    Copy Key
                </button>
                -->
                
                <button class="copy-btn" id="copyMnemonicBtn" disabled>
                    COPY SEED PHRASE
                </button>
                
                <!--
                <button class="copy-btn" id="copyPublicKeyBtn" disabled>
                    Copy Public Key
                </button>
                -->
                
                <!--
                <button class="copy-btn" id="copyDidKeyBtn" disabled>
                    Copy DID Key
                </button>
                -->
            </div>
            
            <div class="restore-section">
                <h3>KEY RECOVERY PROTOCOL</h3>
                <p class="restore-subtitle">Input 24-word seed phrase to reconstruct cryptographic key</p>
                
                <div class="mnemonic-input-container">
                    <textarea 
                        id="mnemonicInput" 
                        placeholder="Enter seed phrase..."
                        rows="3"
                    ></textarea>
                </div>
                
                <div class="restore-button-group">
                    <button class="restore-btn" id="restoreBtn">
                        RECONSTRUCT KEY
                    </button>
                    
                    <button class="clear-btn" id="clearBtn">
                        CLEAR
                    </button>
                </div>
            </div>
        </div>
        
        <div class="clear-key-section" id="clearKeySection" style="display: none;">
            <button class="clear-btn" id="clearKeyBtn">
                CLEAR CURRENT KEY
            </button>
        </div>
        
        <!--
        <div class="info">
            <h3>About This Tool</h3>
            <p>
                This tool generates cryptographically secure 256-bit private keys using the Web Crypto API. 
                The key is generated entirely in your browser and never transmitted over the network. 
                Each key is unique and suitable for cryptographic operations. The tool also generates 
                a corresponding BIP39 mnemonic phrase for easier backup and recovery, computes the 
                secp256k1 public key for use in blockchain applications, and formats the public key 
                as a DID key for decentralized identity use cases. You can also restore a private 
                key from a valid BIP39 mnemonic phrase.
            </p>
        </div>
        -->
        
        <div class="status"></div>
            </div>
            
            <!-- Create Account Tab -->
            <div class="tab-pane" id="createaccount-pane">
                <div class="plc-form-container">
                    <h2>Create New Account</h2>
                    <p class="plc-subtitle">Create a new ATProto account using your browser-controlled DID:PLC identity</p>
                    
                    <form id="createaccount-form" class="plc-form">
                        <div class="form-group">
                            <label for="pds-endpoint">PDS Endpoint</label>
                            <input type="url" id="pds-endpoint" name="pdsEndpoint" placeholder="https://your-pds.example.com" required>
                            <small class="form-help">The URL of your Personal Data Server</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="account-handle">Handle</label>
                            <input type="text" id="account-handle" name="handle" placeholder="username" required>
                            <small class="form-help">Your desired handle (username) for the account</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="account-email">Email</label>
                            <input type="email" id="account-email" name="email" placeholder="user@example.com" required>
                            <small class="form-help">Email address for account verification</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="account-password">Password</label>
                            <input type="password" id="account-password" name="password" placeholder="Secure password" required>
                            <small class="form-help">Password for account authentication</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="account-invite-code">Invite Code (Optional)</label>
                            <input type="text" id="account-invite-code" name="inviteCode" placeholder="Enter invite code if required">
                            <small class="form-help">Optional: Some PDS servers require an invite code for account creation</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="account-did">DID:PLC Identifier</label>
                            <input type="text" id="account-did" name="did" placeholder="did:plc:..." readonly>
                            <small class="form-help">Your browser-controlled DID:PLC identifier (auto-generated from DID:PLC Entry tab)</small>
                        </div>
                        
                        <div class="form-button-group">
                            <button type="submit" class="submit-btn" id="submit-createaccount-btn">
                                Create Account
                            </button>
                            <button type="button" class="clear-btn" id="clear-createaccount-btn">
                                Clear Form
                            </button>
                        </div>
                    </form>
                    
                    <div class="plc-result" id="createaccount-result" style="display: none;">
                        <h3>Account Created Successfully</h3>
                        <div class="plc-result-content" id="createaccount-result-content"></div>
                        <button class="copy-btn" id="copy-createaccount-result-btn">
                            Copy Account Details
                        </button>
                    </div>
                </div>
                
                <div class="status"></div>
            </div>
            
            <!-- DID:PLC Entry Tab -->
            <div class="tab-pane" id="didplc-pane">
                <div class="plc-form-container">
                    <h2>DID:PLC Entry Form</h2>
                    <p class="plc-subtitle">Create a DID:PLC entry with all required fields for decentralized identity</p>
                    
                    <form id="didplc-form" class="plc-form">
                        <div class="form-group">
                            <label for="plc-did">DID Identifier</label>
                            <input type="text" id="plc-did" name="did" placeholder="did:plc:example" required>
                            <small class="form-help">The decentralized identifier (e.g., did:plc:abc123) - click "Fetch Record" to load existing data</small>
                            <div class="did-button-group">
                                <button type="button" class="fetch-btn" id="fetch-did-btn">
                                    Fetch Record
                                </button>
                                <button type="button" class="verify-btn" id="verify-did-btn">
                                    Verify Creation
                                </button>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Rotation Keys</label>
                            <div id="rotation-keys-container">
                                <div class="rotation-key-group">
                                    <input type="text" class="rotation-key-input" placeholder="Enter rotation key" required>
                                    <button type="button" class="remove-rotation-key-btn" style="display: none;">Remove</button>
                                </div>
                            </div>
                            <button type="button" id="add-rotation-key-btn">Add Rotation Key</button>
                            <small class="form-help">Public keys used for key rotation</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="plc-atproto-verification-method">ATProto Verification Method</label>
                            <div class="did-input-group">
                                <input type="text" id="plc-atproto-verification-method" name="atprotoVerificationMethod" placeholder="Enter ATProto verification method (did:key:...)" required>
                                <button type="button" class="fetch-btn" id="reserve-key-btn">
                                    Reserve Key
                                </button>
                            </div>
                            <small class="form-help">The verification method used for ATProto authentication</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="plc-pds-endpoint">PDS Endpoint</label>
                            <input type="text" id="plc-pds-endpoint" name="pdsEndpoint" placeholder="Enter PDS endpoint URL (e.g., https://bsky.social)" required>
                            <small class="form-help">The ATProto Personal Data Server endpoint URL</small>
                        </div>
                        
                        <div class="form-group">
                            <label>Also Known As</label>
                            <div id="also-known-as-container">
                                <div class="also-known-as-group">
                                    <input type="text" class="also-known-as-input" placeholder="Enter alternative identifier (e.g., at://goat.navy)">
                                    <button type="button" class="remove-also-known-as-btn" style="display: none;">Remove</button>
                                </div>
                            </div>
                            <button type="button" id="add-also-known-as-btn">Add Also Known As</button>
                            <small class="form-help">Optional: Alternative identifiers or handles</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="plc-previous-update">Previous Update</label>
                            <input type="text" id="plc-previous-update" name="previousUpdate" placeholder="Previous update operation CID (if applicable)">
                            <small class="form-help">Optional: CID of the previous update operation for operation history</small>
                        </div>
                        
                        <div class="form-button-group">
                            <button type="submit" class="submit-btn" id="submit-plc-btn">
                                Create DID:PLC Entry
                            </button>
                            <button type="button" class="clear-btn" id="clear-plc-btn">
                                Clear Form
                            </button>
                        </div>
                    </form>
                    
                    <div class="plc-result" id="plc-result" style="display: none;">
                        <h3>Generated DID:PLC Entry</h3>
                        <div class="plc-result-content" id="plc-result-content"></div>
                        <button class="copy-btn" id="copy-plc-result-btn">
                            Copy DID:PLC Entry
                        </button>
                    </div>
                    
                    <div class="plc-debug" id="plc-debug" style="display: none;">
                        <h3>Raw Audit Log (Debug)</h3>
                        <div class="plc-debug-content" id="plc-debug-content"></div>
                        <button class="copy-btn" id="copy-plc-debug-btn">
                            Copy Raw Audit Log
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script type="importmap">
{
  "imports": {
    "@noble/secp256k1": "https://cdn.jsdelivr.net/npm/@noble/secp256k1@1.7.1/+esm",
    "@ipld/dag-cbor": "https://cdn.jsdelivr.net/npm/@ipld/dag-cbor@8.0.0/+esm",
    "multiformats": "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/+esm",
    "multiformats/hashes/digest": "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/hashes/digest/+esm",
    "multiformats/bases/base32": "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/bases/base32/+esm",
    "multiformats/bases/base58": "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/bases/base58/+esm",
    "web-bip39": "https://cdn.jsdelivr.net/npm/web-bip39@0.0.3/+esm",
    "web-bip39/wordlists/english": "https://cdn.jsdelivr.net/npm/web-bip39@0.0.3/wordlists/english/+esm"
  },
  "integrity": {
    "https://cdn.jsdelivr.net/npm/@noble/secp256k1@1.7.1/+esm": "ctF+yeUqAx/BuCR1QMviAGExEtYktU/hLf0RaqE+6V5Hbccfz9I3wUyWuQjepyov",
    "https://cdn.jsdelivr.net/npm/@ipld/dag-cbor@8.0.0/+esm": "ogi9Z1IShai42xaSfEhEPGl9UlOy7Cpsq52JiyP3Ik2feZj9fBHteG1kYvzCIgCl",
    "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/+esm": "B0j/2wLtD2+/EZcYrzOjUvwEXx87AdCjPF4xFz4k7bHeymSJRHp5S9cLKXjpb5YS",
    "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/hashes/digest/+esm": "bvAY3ic3D+s0En+kCksxQd1YV/afOcP3t8oO42or3Wfz43+ZbLuOBqe6+S2VpUjs",
    "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/bases/base32/+esm": "jaXtohQBfIBXnv9IEpsN6RslnX39hb3eqXy2MiFpIVg/9hbsd2lJavXZrWyL7Qej",
    "https://cdn.jsdelivr.net/npm/multiformats@12.1.3/bases/base58/+esm": "JSVfRv4iQSuHhDXXP5LoY5ceaJWHAGW0GqDB66zF+6uiEeQQCJ5YzkywnevVYZ8r",
    "https://cdn.jsdelivr.net/npm/web-bip39@0.0.3/+esm": "Y46f3ugMRf7cyTHzBi/mbYEELht5cyicuk6xT0uJODxnFR/Ceec96MfeElu9iy5F",
    "https://cdn.jsdelivr.net/npm/web-bip39@0.0.3/wordlists/english/+esm": "oFf/ljuhMXEEidj8NdBIOABU2ROaoFbqu597MLHK7ohE8+xC9djwwzlbryW6yiVV"
  }
}
</script>

    <script type="module">
        import * as secp256k1 from '@noble/secp256k1';
        import { encode as dagCborEncode } from '@ipld/dag-cbor';
        import { CID } from 'multiformats';
        import * as digest from 'multiformats/hashes/digest';
        import { base32 } from 'multiformats/bases/base32';
        import { base58btc } from 'multiformats/bases/base58';
        import { generateMnemonic, validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from 'web-bip39';
        import wordlist from 'web-bip39/wordlists/english';
        
        let currentKey = null;
        let currentMnemonic = null;
        let currentPublicKey = null;
        let currentDidKey = null;
        
        
        // Generate secp256k1 public key from private key
        function generatePublicKey(privateKeyHex) {
            try {
                // Convert hex string to Uint8Array
                const privateKeyBytes = new Uint8Array(32);
                for (let i = 0; i < privateKeyHex.length; i += 2) {
                    privateKeyBytes[i / 2] = parseInt(privateKeyHex.substr(i, 2), 16);
                }
                
                // Generate public key using @noble/secp256k1
                const publicKeyBytes = secp256k1.getPublicKey(privateKeyBytes, true); // true = compressed
                
                // Convert public key bytes to hex string
                const publicKeyHex = Array.from(publicKeyBytes)
                    .map(byte => byte.toString(16).padStart(2, '0'))
                    .join('');
                
                return publicKeyHex;
            } catch (error) {
                console.error('Error generating public key:', error);
                throw new Error('Failed to generate public key: ' + error.message);
            }
        }

        // Generate DID key from secp256k1 public key
        function generateDidKey(publicKeyHex) {
            try {
                // Convert hex string to Uint8Array
                const publicKeyBytes = new Uint8Array(33);
                for (let i = 0; i < publicKeyHex.length; i += 2) {
                    publicKeyBytes[i / 2] = parseInt(publicKeyHex.substr(i, 2), 16);
                }
                
                // Add multicodec prefix for secp256k1 compressed public key (0xe7)
                const multicodecPrefix = new Uint8Array([0xe7, 0x01]);
                const prefixedKey = new Uint8Array([...multicodecPrefix, ...publicKeyBytes]);
                
                // Encode using base58
                const encoded = base58btc.encode(prefixedKey);
                
                // Construct DID key with 'z' prefix for base58btc
                const didKey = `did:key:z${encoded}`;
                
                return didKey;
            } catch (error) {
                console.error('Error generating DID key:', error);
                throw new Error('Failed to generate DID key: ' + error.message);
            }
        }

        async function generateKey() {
            const keyDisplay = document.getElementById('keyDisplay');
            const mnemonicDisplay = document.getElementById('mnemonicDisplay');
            const mnemonicText = document.getElementById('mnemonicText');
            const publicKeyDisplay = document.getElementById('publicKeyDisplay');
            const publicKeyText = document.getElementById('publicKeyText');
            const didKeyDisplay = document.getElementById('didKeyDisplay');
            const didKeyText = document.getElementById('didKeyText');
            const copyBtn = document.getElementById('copyBtn');
            const copyMnemonicBtn = document.getElementById('copyMnemonicBtn');
            const copyPublicKeyBtn = document.getElementById('copyPublicKeyBtn');
            const copyDidKeyBtn = document.getElementById('copyDidKeyBtn');
            const generateBtn = document.getElementById('generateBtn');
            const status = getCurrentStatusElement();

            try {
                // Show loading state
                if (generateBtn) generateBtn.disabled = true;
                if (generateBtn) generateBtn.textContent = 'Generating...';
                if (keyDisplay) keyDisplay.textContent = 'Generating secure random key, mnemonic, and public key...';
                if (mnemonicDisplay) mnemonicDisplay.style.display = 'none';
                if (publicKeyDisplay) publicKeyDisplay.style.display = 'none';
                if (status) status.innerHTML = '';

                // Generate 256 bits (32 bytes) of random data
                const randomBytes = new Uint8Array(32);
                crypto.getRandomValues(randomBytes);

                // Convert to hexadecimal string
                currentKey = Array.from(randomBytes)
                    .map(byte => byte.toString(16).padStart(2, '0'))
                    .join('');

                // Generate BIP39 mnemonic from the entropy
                currentMnemonic = await entropyToMnemonic(randomBytes, wordlist);

                // Generate secp256k1 public key
                currentPublicKey = generatePublicKey(currentKey);

                // Generate DID key
                currentDidKey = generateDidKey(currentPublicKey);

                // Display the key
                if (keyDisplay) keyDisplay.textContent = currentKey;
                if (keyDisplay) keyDisplay.classList.add('has-key');
                
                // Display the mnemonic
                if (mnemonicText) mnemonicText.textContent = currentMnemonic;
                if (mnemonicDisplay) mnemonicDisplay.style.display = 'block';
                
                // Display the public key
                if (publicKeyText) publicKeyText.textContent = currentPublicKey;
                if (publicKeyDisplay) publicKeyDisplay.style.display = 'block';
                
                // Display the DID key
                if (didKeyText) didKeyText.textContent = currentDidKey;
                if (didKeyDisplay) didKeyDisplay.style.display = 'block';
                
                // Enable copy buttons
                if (copyBtn) copyBtn.disabled = false;
                if (copyMnemonicBtn) copyMnemonicBtn.disabled = false;
                if (copyPublicKeyBtn) copyPublicKeyBtn.disabled = false;
                if (copyDidKeyBtn) copyDidKeyBtn.disabled = false;
                
                // Update submit button state if we're on the DID:PLC Entry tab
                updateSubmitButtonState();
                
                // Update tab states to enable inactive tabs
                updateTabStates();
                
                // Toggle key generation sections visibility
                toggleKeyGenerationSections();

                if (status) {
                    status.innerHTML = '<div class="status success">Key, mnemonic, public key, and DID key generated successfully!</div>';
                }

            } catch (error) {
                console.error('Error generating key:', error);
                if (status) {
                    status.innerHTML = '<div class="status error">Error generating key. Please try again.</div>';
                }
                if (keyDisplay) keyDisplay.textContent = 'Error generating key. Please try again.';
                if (keyDisplay) keyDisplay.classList.remove('has-key');
                if (mnemonicDisplay) mnemonicDisplay.style.display = 'none';
                if (publicKeyDisplay) publicKeyDisplay.style.display = 'none';
                if (didKeyDisplay) didKeyDisplay.style.display = 'none';
            } finally {
                if (generateBtn) generateBtn.disabled = false;
                if (generateBtn) generateBtn.textContent = 'Generate New Key';
            }
        }

        async function copyKey() {
            if (!currentKey) return;

            try {
                await navigator.clipboard.writeText(currentKey);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status success">Key copied to clipboard!</div>';
                }
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    if (status) {
                        status.innerHTML = '';
                    }
                }, 3000);
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status error">Failed to copy to clipboard</div>';
                }
            }
        }

        async function copyMnemonic() {
            if (!currentMnemonic) return;

            try {
                await navigator.clipboard.writeText(currentMnemonic);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status success">Mnemonic copied to clipboard!</div>';
                }
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    if (status) {
                        status.innerHTML = '';
                    }
                }, 3000);
            } catch (error) {
                console.error('Error copying mnemonic to clipboard:', error);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status error">Failed to copy mnemonic to clipboard</div>';
                }
            }
        }

        async function copyPublicKey() {
            if (!currentPublicKey) return;

            try {
                await navigator.clipboard.writeText(currentPublicKey);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status success">Public key copied to clipboard!</div>';
                }
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    if (status) {
                        status.innerHTML = '';
                    }
                }, 3000);
            } catch (error) {
                console.error('Error copying public key to clipboard:', error);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status error">Failed to copy public key to clipboard</div>';
                }
            }
        }

        async function copyDidKey() {
            if (!currentDidKey) return;

            try {
                await navigator.clipboard.writeText(currentDidKey);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status success">DID key copied to clipboard!</div>';
                }
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    if (status) {
                        status.innerHTML = '';
                    }
                }, 3000);
            } catch (error) {
                console.error('Error copying DID key to clipboard:', error);
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '<div class="status error">Failed to copy DID key to clipboard</div>';
                }
            }
        }

        async function restoreFromMnemonic() {
            const mnemonicInput = document.getElementById('mnemonicInput');
            const keyDisplay = document.getElementById('keyDisplay');
            const mnemonicDisplay = document.getElementById('mnemonicDisplay');
            const mnemonicText = document.getElementById('mnemonicText');
            const publicKeyDisplay = document.getElementById('publicKeyDisplay');
            const publicKeyText = document.getElementById('publicKeyText');
            const didKeyDisplay = document.getElementById('didKeyDisplay');
            const didKeyText = document.getElementById('didKeyText');
            const copyBtn = document.getElementById('copyBtn');
            const copyMnemonicBtn = document.getElementById('copyMnemonicBtn');
            const copyPublicKeyBtn = document.getElementById('copyPublicKeyBtn');
            const copyDidKeyBtn = document.getElementById('copyDidKeyBtn');
            const restoreBtn = document.getElementById('restoreBtn');
            const status = getCurrentStatusElement();

            const inputMnemonic = mnemonicInput.value.trim();

            if (!inputMnemonic) {
                if (status) {
                    status.innerHTML = '<div class="status error">Please enter a mnemonic phrase</div>';
                }
                return;
            }

            try {
                // Show loading state
                if (restoreBtn) restoreBtn.disabled = true;
                if (restoreBtn) restoreBtn.textContent = 'Restoring...';
                if (status) status.innerHTML = '';

                // Validate mnemonic
                const isValid = await validateMnemonic(inputMnemonic, wordlist);
                if (!isValid) {
                    throw new Error('Invalid mnemonic phrase');
                }

                // Convert mnemonic to entropy
                const restoredKeyBytes = await mnemonicToEntropy(inputMnemonic, wordlist);
                
                // Convert Uint8Array to hex string
                const restoredKey = Array.from(restoredKeyBytes)
                    .map(byte => byte.toString(16).padStart(2, '0'))
                    .join('');

                // Generate secp256k1 public key
                const restoredPublicKey = generatePublicKey(restoredKey);

                // Generate DID key
                const restoredDidKey = generateDidKey(restoredPublicKey);

                // Update global variables
                currentKey = restoredKey;
                currentMnemonic = inputMnemonic;
                currentPublicKey = restoredPublicKey;
                currentDidKey = restoredDidKey;

                // Display the restored key
                if (keyDisplay) keyDisplay.textContent = currentKey;
                if (keyDisplay) keyDisplay.classList.add('has-key');
                
                // Display the mnemonic
                if (mnemonicText) mnemonicText.textContent = currentMnemonic;
                if (mnemonicDisplay) mnemonicDisplay.style.display = 'block';
                
                // Display the public key
                if (publicKeyText) publicKeyText.textContent = currentPublicKey;
                if (publicKeyDisplay) publicKeyDisplay.style.display = 'block';
                
                // Display the DID key
                if (didKeyText) didKeyText.textContent = currentDidKey;
                if (didKeyDisplay) didKeyDisplay.style.display = 'block';

                // Enable copy buttons
                if (copyBtn) copyBtn.disabled = false;
                if (copyMnemonicBtn) copyMnemonicBtn.disabled = false;
                if (copyPublicKeyBtn) copyPublicKeyBtn.disabled = false;
                if (copyDidKeyBtn) copyDidKeyBtn.disabled = false;
                
                // Update submit button state if we're on the DID:PLC Entry tab
                updateSubmitButtonState();
                
                // Update tab states to enable inactive tabs
                updateTabStates();
                
                // Toggle key generation sections visibility
                toggleKeyGenerationSections();

                if (status) status.innerHTML = '<div class="status success">Private key, mnemonic, public key, and DID key restored successfully!</div>';

            } catch (error) {
                console.error('Error restoring from mnemonic:', error);
                if (status) status.innerHTML = `<div class="status error">${error.message}</div>`;
                if (keyDisplay) keyDisplay.textContent = 'Error restoring key. Please check your mnemonic phrase.';
                if (keyDisplay) keyDisplay.classList.remove('has-key');
                if (mnemonicDisplay) mnemonicDisplay.style.display = 'none';
                if (publicKeyDisplay) publicKeyDisplay.style.display = 'none';
                if (didKeyDisplay) didKeyDisplay.style.display = 'none';
            } finally {
                if (restoreBtn) restoreBtn.disabled = false;
                if (restoreBtn) restoreBtn.textContent = 'Restore Private Key';
            }
        }

        function clearInput() {
            const mnemonicInput = document.getElementById('mnemonicInput');
            const status = getCurrentStatusElement();
            
            if (mnemonicInput) mnemonicInput.value = '';
            if (status) status.innerHTML = '';
        }

        // Helper function to get the status element for the current active tab
        function getCurrentStatusElement() {
            const activeTab = document.querySelector('.tab-pane.active');
            if (activeTab) {
                const statusElement = activeTab.querySelector('.status');
                if (statusElement) {
                    return statusElement;
                }
            }
            // Fallback: try to find any status element if active tab detection fails
            const fallbackStatus = document.querySelector('.status');
            if (fallbackStatus) {
                return fallbackStatus;
            }
            console.warn('No status element found');
            return null;
        }

        // Fetch actual operation from plc.directory
        async function fetchActualOperation() {
            try {
                const response = await fetch('https://plc.directory/did:plc:pyzlzqt6b2nyrha7smfry6rv/log/audit');
                const data = await response.json();
                const operation = data[0].operation;
                
                // Remove sig field for CID generation
                const operationForCid = { ...operation };
                delete operationForCid.sig;
                
                console.log('Fetched operation from plc.directory:', operationForCid);
                
                // Debug: Compare with expected structure
                console.log('=== Operation Structure Comparison ===');
                console.log('Operation keys:', Object.keys(operationForCid));
                console.log('Operation prev:', operationForCid.prev);
                console.log('Operation type:', operationForCid.type);
                console.log('Operation services:', operationForCid.services);
                console.log('Operation alsoKnownAs:', operationForCid.alsoKnownAs);
                console.log('Operation rotationKeys:', operationForCid.rotationKeys);
                console.log('Operation verificationMethods:', operationForCid.verificationMethods);
                
                return operationForCid;
            } catch (error) {
                console.error('Error fetching operation:', error);
                return null;
            }
        }

        // Test case for DID:PLC ID generation
        async function testDidPlcIdGeneration() {
            console.log('=== DID:PLC ID Generation Test ===');
            
            // Fetch the actual operation with signature from plc.directory
            const testDid = 'did:plc:pyzlzqt6b2nyrha7smfry6rv';
            const expectedCid = 'bafyreid6gk6me7qotoejyh4tbmohuniu37anfgb6lhr2po3btqannss3dq';
            
            try {
                const { didDocument, auditLog } = await fetchDidPlcRecord(testDid);
                const testOperation = auditLog[0].operation; // This includes the signature
                
                console.log('Fetched operation from plc.directory:', testOperation);
                console.log('Operation includes signature:', !!testOperation.sig);
                console.log('Signature value:', testOperation.sig);
                
                console.log('Expected DID:', testDid);
                console.log('Expected CID:', expectedCid);
                
                // Test the DID:PLC ID generation with signed operation
                const generatedDid = await generateDidPlcId(testOperation);
                console.log('Generated DID:', generatedDid);
                console.log('Match:', generatedDid === testDid ? 'PASS' : 'FAIL');
                
                if (generatedDid !== testDid) {
                    console.log('Test failed - generated DID does not match expected');
                    console.log('This may be due to:');
                    console.log('1. Different DAG-CBOR serialization order');
                    console.log('2. Different CID generation method');
                    console.log('3. Different base32 encoding');
                    console.log('4. Missing or incorrect signature');
                } else {
                    console.log('Test passed - DID:PLC ID generation is working correctly!');
                }
                
                return {
                    success: generatedDid === testDid,
                    operation: testOperation,
                    generatedDid: generatedDid,
                    expectedDid: testDid,
                    expectedCid: expectedCid
                };
            } catch (error) {
                console.error('Test failed with error:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // SHA-256 hash function using Web Crypto API
        async function sha256Hash(data) {
            console.log('=== SHA-256 Hash Debug ===');
            console.log('Input data type:', typeof data);
            console.log('Input data constructor:', data.constructor.name);
            console.log('Input data length:', data.length);
            console.log('Input data (first 20 bytes hex):', Array.from(data.slice(0, 20)).map(b => b.toString(16).padStart(2, '0')).join(''));
            console.log('Input data (last 20 bytes hex):', Array.from(data.slice(-20)).map(b => b.toString(16).padStart(2, '0')).join(''));
            
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const result = new Uint8Array(hashBuffer);
            
            console.log('Hash result length:', result.length);
            console.log('Hash result (hex):', Array.from(result).map(b => b.toString(16).padStart(2, '0')).join(''));
            
            return result;
        }

        // Verify a signed DID:PLC operation and recover the public key
        async function verifyDidPlcOperation(signedOperation) {
            try {
                console.log('=== Verifying DID:PLC Operation ===');
                console.log('Signed operation:', signedOperation);
                
                // Extract the signature
                const signatureBase64 = signedOperation.sig;
                console.log('Signature (base64url):', signatureBase64);
                
                // Decode the signature from base64url
                const signatureBase64Standard = signatureBase64
                    .replace(/-/g, '+')
                    .replace(/_/g, '/');
                
                // Add padding if needed
                const padding = signatureBase64Standard.length % 4;
                const paddedSignature = signatureBase64Standard + '='.repeat(padding ? 4 - padding : 0);
                
                const signatureBytes = new Uint8Array(atob(paddedSignature).split('').map(c => c.charCodeAt(0)));
                console.log('Signature bytes (hex):', Array.from(signatureBytes).map(b => b.toString(16).padStart(2, '0')).join(''));
                console.log('Signature length:', signatureBytes.length);
                
                // Create unsigned operation for verification
                const unsignedOperation = { ...signedOperation };
                delete unsignedOperation.sig;
                console.log('Unsigned operation for verification:', unsignedOperation);
                
                // Serialize to DAG-CBOR
                const dagCborBytes = dagCborEncode(unsignedOperation);
                console.log('DAG-CBOR bytes for verification:', Array.from(dagCborBytes).map(b => b.toString(16).padStart(2, '0')).join(''));
                
                // Extract r and s from the 64-byte signature
                const r = signatureBytes.slice(0, 32);
                const s = signatureBytes.slice(32, 64);
                console.log('r (hex):', Array.from(r).map(b => b.toString(16).padStart(2, '0')).join(''));
                console.log('s (hex):', Array.from(s).map(b => b.toString(16).padStart(2, '0')).join(''));
                
                // Hash the DAG-CBOR bytes for signature verification
                const messageHash = await crypto.subtle.digest('SHA-256', dagCborBytes);
                const messageHashHex = Array.from(new Uint8Array(messageHash)).map(b => b.toString(16).padStart(2, '0')).join('');
                console.log('Message hash (SHA-256):', messageHashHex);
                
                // Get all rotation keys to verify against
                const operationRotationKeys = signedOperation.rotationKeys;
                console.log('Operation rotation keys:', operationRotationKeys);
                
                // Try to recover the public key using @noble/secp256k1
                let recoveredPublicKey = null;
                let correctRecovery = null;
                let matchedRotationKey = null;
                
                for (let recovery = 0; recovery <= 1; recovery++) {
                    try {
                        // Create a 64-byte signature (r + s) as hex string
                        const signatureHex = Array.from(r).map(b => b.toString(16).padStart(2, '0')).join('') + 
                                           Array.from(s).map(b => b.toString(16).padStart(2, '0')).join('');
                        
                        console.log(`Trying recovery ${recovery} with signature hex:`, signatureHex);
                        console.log(`Signature hex length:`, signatureHex.length, 'characters');
                        
                        // Use correct API: recoverPublicKey(hash, signature, recovery)
                        const recovered = secp256k1.recoverPublicKey(messageHashHex, signatureHex, recovery, true);
                        
                        if (recovered) {
                            console.log(`Recovered public key with recovery ${recovery}:`, Array.from(recovered).map(b => b.toString(16).padStart(2, '0')).join(''));
                            
                            // Generate DID:key from recovered public key
                            const recoveredPublicKeyHex = Array.from(recovered).map(b => b.toString(16).padStart(2, '0')).join('');
                            const recoveredDidKey = generateDidKey(recoveredPublicKeyHex);
                            console.log(`Recovered DID:key with recovery ${recovery}:`, recoveredDidKey);
                            
                            // Check if this matches any of the rotation keys
                            let foundMatch = false;
                            for (let i = 0; i < operationRotationKeys.length; i++) {
                                const rotationKey = operationRotationKeys[i];
                                console.log(`Checking against rotation key ${i}:`, rotationKey);
                                
                                if (recoveredDidKey === rotationKey) {
                                    console.log(`Recovery ${recovery} matches rotation key ${i}!`);
                                    recoveredPublicKey = recovered;
                                    correctRecovery = recovery;
                                    matchedRotationKey = rotationKey;
                                    foundMatch = true;
                                    break;
                                } else {
                                    console.log(`Recovery ${recovery} does not match rotation key ${i}`);
                                }
                            }
                            
                            if (foundMatch) {
                                break;
                            }
                        }
                    } catch (e) {
                        console.log(`Recovery ${recovery} failed:`, e.message);
                    }
                }
                
                if (!recoveredPublicKey) {
                    throw new Error('Could not recover public key from signature that matches the expected rotation key');
                }
                
                console.log(`Successfully recovered correct public key with recovery ${correctRecovery}`);
                console.log(`Matched rotation key:`, matchedRotationKey);
                
                // Generate DID:key from recovered public key (for final comparison)
                const recoveredPublicKeyHex = Array.from(recoveredPublicKey).map(b => b.toString(16).padStart(2, '0')).join('');
                const recoveredDidKey = generateDidKey(recoveredPublicKeyHex);
                console.log('Final recovered DID:key:', recoveredDidKey);
                console.log('Keys match:', recoveredDidKey === matchedRotationKey);
                
                // Also verify using the known public key (if available)
                let knownDidKey = null;
                let knownKeyMatches = false;
                
                if (currentPublicKey) {
                    const knownPublicKeyHex = currentPublicKey;
                    knownDidKey = generateDidKey(knownPublicKeyHex);
                    console.log('Known DID:key:', knownDidKey);
                    console.log('Known key matches recovered:', recoveredDidKey === knownDidKey);
                    console.log('Known key matches operation:', knownDidKey === matchedRotationKey);
                    knownKeyMatches = knownDidKey === matchedRotationKey;
                } else {
                    console.log('No current public key available for comparison');
                }
                
                return {
                    success: true,
                    recoveredPublicKey: recoveredPublicKeyHex,
                    recoveredDidKey: recoveredDidKey,
                    operationRotationKey: matchedRotationKey,
                    knownDidKey: knownDidKey,
                    keysMatch: recoveredDidKey === matchedRotationKey,
                    knownKeyMatches: knownKeyMatches
                };
                
            } catch (error) {
                console.error('Error verifying DID:PLC operation:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Submit a signed DID:PLC operation to plc.directory
        async function submitDidPlcOperation(signedOperation, didPlcId) {
            try {
                console.log('=== Submitting DID:PLC Operation ===');
                console.log('Operation to submit:', signedOperation);
                console.log('DID:PLC ID:', didPlcId);
                
                // Use the DID:PLC ID in the endpoint URL
                const endpoint = `https://plc.directory/${didPlcId}`;
                console.log('Submitting to endpoint:', endpoint);
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(signedOperation)
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Submission failed:', errorText);
                    throw new Error(`Failed to submit operation: ${response.status} ${response.statusText}\n${errorText}`);
                }
                
                // plc.directory returns plain text, not JSON
                const resultText = await response.text();
                console.log('Submission successful:', resultText);
                
                return { success: true, message: resultText };
                
            } catch (error) {
                console.error('Error submitting DID:PLC operation:', error);
                throw error;
            }
        }

        // Reserve a signing key on the PDS
        async function reserveSigningKey(pdsEndpoint, did) {
            try {
                console.log('=== Reserving Signing Key ===');
                console.log('PDS Endpoint:', pdsEndpoint);
                console.log('DID:', did);
                
                const endpoint = `${pdsEndpoint}/xrpc/com.atproto.server.reserveSigningKey`;
                console.log('Reserving at endpoint:', endpoint);
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        did: did
                    })
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Reservation failed:', errorText);
                    throw new Error(`Failed to reserve signing key: ${response.status} ${response.statusText}\n${errorText}`);
                }
                
                const result = await response.json();
                console.log('Reservation successful:', result);
                
                return { success: true, result: result };
                
            } catch (error) {
                console.error('Error reserving signing key:', error);
                throw error;
            }
        }

        // Create an account on the PDS
        async function createAccount(pdsEndpoint, handle, email, password, recoveryKey, inviteCode) {
            try {
                console.log('=== Creating Account ===');
                console.log('PDS Endpoint:', pdsEndpoint);
                console.log('Handle:', handle);
                console.log('Email:', email);
                console.log('Recovery Key:', recoveryKey);
                
                const endpoint = `${pdsEndpoint}/xrpc/com.atproto.server.createAccount`;
                console.log('Creating account at endpoint:', endpoint);
                
                const requestBody = {
                    handle: handle,
                    email: email,
                    password: password,
                    recoveryKey: recoveryKey
                };
                
                // Add invite code if provided
                if (inviteCode && inviteCode.trim()) {
                    requestBody.inviteCode = inviteCode.trim();
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Account creation failed:', errorText);
                    throw new Error(`Failed to create account: ${response.status} ${response.statusText}\n${errorText}`);
                }
                
                const result = await response.json();
                console.log('Account creation successful:', result);
                
                return { success: true, result: result };
                
            } catch (error) {
                console.error('Error creating account:', error);
                throw error;
            }
        }

        // Sign a DID:PLC operation with the current key
        async function signDidPlcOperation(operation, privateKeyHex) {
            try {
                console.log('=== Signing DID:PLC Operation ===');
                console.log('Operation to sign:', operation);
                console.log('Private key (hex):', privateKeyHex);
                
                // Create a copy without the signature for signing
                const operationForSigning = { ...operation };
                delete operationForSigning.sig;
                
                console.log('Operation for signing (without sig):', operationForSigning);
                
                // Serialize to DAG-CBOR
                const dagCborBytes = dagCborEncode(operationForSigning);
                console.log('DAG-CBOR bytes for signing:', Array.from(dagCborBytes).map(b => b.toString(16).padStart(2, '0')).join(''));
                
                // Hash the DAG-CBOR bytes with SHA-256 before signing
                const messageHash = await crypto.subtle.digest('SHA-256', dagCborBytes);
                const messageHashHex = Array.from(new Uint8Array(messageHash)).map(b => b.toString(16).padStart(2, '0')).join('');
                console.log('Message hash (SHA-256):', messageHashHex);
                
                // Convert hex private key to Uint8Array
                const privateKeyBytes = new Uint8Array(32);
                for (let i = 0; i < privateKeyHex.length; i += 2) {
                    privateKeyBytes[i / 2] = parseInt(privateKeyHex.substr(i, 2), 16);
                }
                
                // Sign the hashed message using @noble/secp256k1
                const signature = await secp256k1.sign(messageHashHex, privateKeyBytes);
                console.log('Signature object:', signature);
                console.log('Signature object type:', typeof signature);
                console.log('Signature object constructor:', signature.constructor.name);
                console.log('Signature object methods:', Object.getOwnPropertyNames(signature));
                console.log('Signature object prototype methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(signature)));
                console.log('Signature object keys:', Object.keys(signature));
                console.log('Signature object values:', Object.values(signature));
                
                // Check for common signature properties
                console.log('Has toCompactRawBytes:', 'toCompactRawBytes' in signature);
                console.log('Has toBytes:', 'toBytes' in signature);
                console.log('Has toCompactHex:', 'toCompactHex' in signature);
                console.log('Has r:', 'r' in signature);
                console.log('Has s:', 's' in signature);
                console.log('Has recovery:', 'recovery' in signature);
                
                // Convert signature to base64url
                let signatureArray;
                
                if (signature instanceof Uint8Array) {
                    // Signature is already a Uint8Array (DER format)
                    console.log('Signature is Uint8Array, length:', signature.length);
                    console.log('Signature bytes (hex):', Array.from(signature).map(b => b.toString(16).padStart(2, '0')).join(''));
                    
                    // Convert DER to compact format (64 bytes)
                    if (signature.length >= 68 && signature[0] === 0x30) {
                        // Parse DER structure dynamically
                        let offset = 2; // Skip 0x30 [length]
                        
                        // Parse r value
                        if (signature[offset] !== 0x02) {
                            throw new Error('Invalid DER format: expected r value marker');
                        }
                        offset++; // Skip 0x02
                        const rLength = signature[offset];
                        offset++; // Skip r length
                        const rBytes = signature.slice(offset, offset + rLength);
                        offset += rLength;
                        
                        // Parse s value
                        if (signature[offset] !== 0x02) {
                            throw new Error('Invalid DER format: expected s value marker');
                        }
                        offset++; // Skip 0x02
                        const sLength = signature[offset];
                        offset++; // Skip s length
                        const sBytes = signature.slice(offset, offset + sLength);
                        
                        // Remove leading zero byte from r if present
                        const rCompact = rBytes[0] === 0 ? rBytes.slice(1) : rBytes;
                        
                        // Create compact signature (64 bytes)
                        signatureArray = new Uint8Array(64);
                        signatureArray.set(rCompact, 0);
                        signatureArray.set(sBytes, 32);
                        
                        console.log('DER structure parsed:');
                        console.log('- r length:', rLength, 'bytes');
                        console.log('- s length:', sLength, 'bytes');
                        console.log('- r compact length:', rCompact.length, 'bytes');
                        console.log('- Converted to compact signature, length:', signatureArray.length);
                        console.log('Compact signature (hex):', Array.from(signatureArray).map(b => b.toString(16).padStart(2, '0')).join(''));
                    } else {
                        throw new Error('Unexpected DER signature format');
                    }
                } else {
                    throw new Error('Signature is not Uint8Array');
                }
                const signatureBase64 = btoa(String.fromCharCode(...signatureArray))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
                
                console.log('Generated signature (base64url):', signatureBase64);
                
                // Add signature to operation
                const signedOperation = { ...operation };
                signedOperation.sig = signatureBase64;
                
                console.log('Signed operation:', signedOperation);
                
                return signedOperation;
                
            } catch (error) {
                console.error('Error signing DID:PLC operation:', error);
                throw error;
            }
        }

        // Generate a DID:PLC ID from operation
        async function generateDidPlcId(operation) {
            try {
                // For testing with real data, include the signature
                // In production, you'd sign the unsigned operation first
                const operationForHash = { ...operation };
                
                console.log('Operation includes signature:', !!operationForHash.sig);
                console.log('Operation for hashing:', operationForHash);
                
                // Serialize operation to DAG-CBOR
                const dagCborBytes = dagCborEncode(operationForHash);
                
                // Debug: Output the DAG-CBOR bytes
                console.log('DAG-CBOR bytes length:', dagCborBytes.length);
                console.log('DAG-CBOR bytes (hex):', Array.from(dagCborBytes).map(b => b.toString(16).padStart(2, '0')).join(''));
                
                // Hash the DAG-CBOR bytes with SHA-256
                const hashBytes = await sha256Hash(dagCborBytes);
                
                console.log('SHA-256 hash (hex):', Array.from(hashBytes).map(b => b.toString(16).padStart(2, '0')).join(''));
                
                // Convert hash to base32 and take first 24 characters
                const hashBase32 = base32.encode(hashBytes);
                console.log('Hash base32:', hashBase32);
                
                // Remove 'b' prefix and padding, then take first 24 characters
                const base32Part = hashBase32.substring(1).replace(/=/g, '');
                console.log('Base32 part (no prefix/padding):', base32Part);
                console.log('Base32 part length:', base32Part.length);
                
                const didPlcId = base32Part.substring(0, 24);
                console.log('Extracted DID:PLC ID (first 24 chars):', didPlcId);
                console.log('Expected DID:PLC ID: pyzlzqt6b2nyrha7smfry6rv');
                
                return `did:plc:${didPlcId}`;
                
                // Debug: Check multihash digest structure
                console.log('Multihash digest object:', multihashDigest);
                console.log('Multihash digest has code property:', 'code' in multihashDigest);
                console.log('Multihash digest has size property:', 'size' in multihashDigest);
                console.log('Multihash digest has bytes property:', 'bytes' in multihashDigest);
                console.log('Multihash digest has digest property:', 'digest' in multihashDigest);
                
                // Debug: Output multihash digest details
                console.log('Multihash digest code:', multihashDigest.code);
                console.log('Multihash digest size:', multihashDigest.size);
                console.log('Multihash digest bytes (hex):', Array.from(multihashDigest.bytes).map(b => b.toString(16).padStart(2, '0')).join(''));
                console.log('Multihash digest bytes length:', multihashDigest.bytes.length);
                
                // Create CID from the digest
                console.log('Creating CID with:');
                console.log('- Version: 1');
                console.log('- Codec: 0x71 (113)');
                console.log('- Multihash digest:', multihashDigest);
                console.log('- Multihash digest code:', multihashDigest.code);
                console.log('- Multihash digest size:', multihashDigest.size);
                console.log('- Multihash digest bytes length:', multihashDigest.bytes.length);
                
                cid = CID.create(1, 0x71, multihashDigest); // CIDv1 with DAG-CBOR codec (0x71)
                
                // Debug: Decode the generated CID to see its raw bytes (including header)
                const generatedCidBase32 = cid.toString(base32);
                console.log('Generated CID base32 string:', generatedCidBase32);
                
                // Use the CID's bytes property directly if available
                if (cid.bytes) {
                    const generatedCidHex = Array.from(cid.bytes).map(b => b.toString(16).padStart(2, '0')).join('');
                    console.log('Generated CID raw bytes (hex):', generatedCidHex);
                    console.log('Generated CID length:', cid.bytes.length);
                    
                    if (cid.bytes.length >= 2) {
                        const version = cid.bytes[0];
                        const codec = cid.bytes[1];
                        const multihash = cid.bytes.slice(2);
                        console.log('Generated CID version:', version);
                        console.log('Generated CID codec:', codec);
                        console.log('Generated CID multihash (hex):', Array.from(multihash).map(b => b.toString(16).padStart(2, '0')).join(''));
                        
                        if (multihash.length >= 2) {
                            const mhCode = multihash[0];
                            const mhSize = multihash[1];
                            const mhDigest = multihash.slice(2);
                            console.log('Generated multihash code:', mhCode);
                            console.log('Generated multihash size:', mhSize);
                            console.log('Generated multihash digest (hex):', Array.from(mhDigest).map(b => b.toString(16).padStart(2, '0')).join(''));
                        }
                    }
                } else {
                    console.log('CID.bytes not available, trying base32 decode...');
                    // Fallback to base32 decoding - decode the full base32 string including 'b' prefix
                    const generatedCidStandardBase32 = generatedCidBase32.toUpperCase();
                    const generatedCidPadded = generatedCidStandardBase32 + '='.repeat((8 - generatedCidStandardBase32.length % 8) % 8);
                    
                    try {
                        // Decode base32 to get raw CID bytes (including header)
                        const generatedCidBytes = new Uint8Array(
                            atob(generatedCidPadded.replace(/-/g, '+').replace(/_/g, '/'))
                                .split('')
                                .map(c => c.charCodeAt(0))
                        );
                        
                        // Convert to hex
                        const generatedCidHex = Array.from(generatedCidBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                        console.log('Generated CID raw bytes (hex):', generatedCidHex);
                        console.log('Generated CID length:', generatedCidBytes.length);
                        
                        if (generatedCidBytes.length >= 2) {
                            const version = generatedCidBytes[0];
                            const codec = generatedCidBytes[1];
                            const multihash = generatedCidBytes.slice(2);
                            console.log('Generated CID version:', version);
                            console.log('Generated CID codec:', codec);
                            console.log('Generated CID multihash (hex):', Array.from(multihash).map(b => b.toString(16).padStart(2, '0')).join(''));
                        }
                    } catch (e) {
                        console.log('Error decoding generated CID:', e);
                    }
                }
                
                // Debug: Output the CID before base32 encoding
                console.log('Generated CID:', cid.toString());
                console.log('Expected CID:', 'bafyreid6gk6me7qotoejyh4tbmohuniu37anfgb6lhr2po3btqannss3dq');
                console.log('CID match:', cid.toString() === 'bafyreid6gk6me7qotoejyh4tbmohuniu37anfgb6lhr2po3btqannss3dq' ? 'MATCH' : 'NO MATCH');
                
                // Debug: Check if the issue is in CID generation or base32 encoding
                console.log('CID version:', cid.version);   
                console.log('CID codec:', cid.code);
                console.log('CID multihash:', cid.multihash);
                console.log('CID multihash code:', cid.multihash.code);
                console.log('CID multihash size:', cid.multihash.size);
                console.log('CID multihash digest (hex):', Array.from(cid.multihash.digest).map(b => b.toString(16).padStart(2, '0')).join(''));
                
            } catch (error) {
                console.error('Error generating DID:PLC ID:', error);
                throw new Error('Failed to generate DID:PLC ID: ' + error.message);
            }
            
            // Get base32 representation of CID
            const cidBase32 = cid.toString(base32);
            
            // Debug: Output base32 encoding details
            console.log('CID base32:', cidBase32);
            console.log('Expected base32 for CID bafyreid6gk6me7qotoejyh4tbmohuniu37anfgb6lhr2po3btqannss3dq:');
            
            // Extract the base32 part (remove 'b' prefix and '=' padding)
            const base32Part = cidBase32.substring(1).replace(/=/g, '');
            
            // Debug: Output base32 part
            console.log('Base32 part (no prefix/padding):', base32Part);
            console.log('Base32 part length:', base32Part.length);
            
            // Take first 24 characters for DID:PLC ID
            const didPlcId = base32Part.substring(0, 24);
            
            // Debug: Output DID:PLC ID extraction
            console.log('Extracted DID:PLC ID (first 24 chars):', didPlcId);
            console.log('Expected DID:PLC ID: pyzlzqt6b2nyrha7smfry6rv');
            
            return `did:plc:${didPlcId}`;
        }

        // Make functions globally accessible for onclick handlers
        window.generateKey = generateKey;
        window.copyKey = copyKey;
        window.copyMnemonic = copyMnemonic;
        window.copyPublicKey = copyPublicKey;
        window.copyDidKey = copyDidKey;
        window.restoreFromMnemonic = restoreFromMnemonic;
        window.clearInput = clearInput;
        window.testDidPlcIdGeneration = testDidPlcIdGeneration;
        window.signDidPlcOperation = signDidPlcOperation;
        window.submitDidPlcOperation = submitDidPlcOperation;
        window.verifyDidPlcOperation = verifyDidPlcOperation;

        // Add event listeners
        const generateBtn = document.getElementById('generateBtn');
        const copyBtn = document.getElementById('copyBtn');
        const copyMnemonicBtn = document.getElementById('copyMnemonicBtn');
        const copyPublicKeyBtn = document.getElementById('copyPublicKeyBtn');
        const copyDidKeyBtn = document.getElementById('copyDidKeyBtn');
        const restoreBtn = document.getElementById('restoreBtn');
        const clearBtn = document.getElementById('clearBtn');
        
        if (generateBtn) generateBtn.addEventListener('click', generateKey);
        if (copyBtn) copyBtn.addEventListener('click', copyKey);
        if (copyMnemonicBtn) copyMnemonicBtn.addEventListener('click', copyMnemonic);
        if (copyPublicKeyBtn) copyPublicKeyBtn.addEventListener('click', copyPublicKey);
        if (copyDidKeyBtn) copyDidKeyBtn.addEventListener('click', copyDidKey);
        if (restoreBtn) restoreBtn.addEventListener('click', restoreFromMnemonic);
        if (clearBtn) clearBtn.addEventListener('click', clearInput);
        
        // Add event listener for clear key button
        const clearKeyBtn = document.getElementById('clearKeyBtn');
        if (clearKeyBtn) clearKeyBtn.addEventListener('click', clearCurrentKey);

        // Tab switching functionality
        function switchTab(tabName) {
            // Check if tab is inactive and trying to switch to it
            const tabButton = document.getElementById(tabName + '-tab');
            if (tabButton && tabButton.classList.contains('inactive')) {
                console.log('Tab is inactive. Please generate or load a key first.');
                return;
            }
            
            // Hide all tab panes
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab pane
            document.getElementById(tabName + '-pane').classList.add('active');
            
            // Add active class to selected tab button
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        // Add tab event listeners
        const keygenTab = document.getElementById('keygen-tab');
        const didplcTab = document.getElementById('didplc-tab');
        const createaccountTab = document.getElementById('createaccount-tab');
        
        if (keygenTab) keygenTab.addEventListener('click', () => switchTab('keygen'));
        if (didplcTab) didplcTab.addEventListener('click', () => switchTab('didplc'));
        if (createaccountTab) createaccountTab.addEventListener('click', () => switchTab('createaccount'));
        
        // Initialize tab states on page load
        updateTabStates();
        
        // Initialize key generation sections visibility
        toggleKeyGenerationSections();

        // Function to update tab states based on whether a key is available
        function updateTabStates() {
            const hasKey = currentKey !== null;
            const createAccountTab = document.getElementById('createaccount-tab');
            const didplcTab = document.getElementById('didplc-tab');
            
            if (hasKey) {
                // Remove inactive class if key is available
                if (createAccountTab) createAccountTab.classList.remove('inactive');
                if (didplcTab) didplcTab.classList.remove('inactive');
            } else {
                // Add inactive class if no key is available
                if (createAccountTab) createAccountTab.classList.add('inactive');
                if (didplcTab) didplcTab.classList.add('inactive');
            }
        }

        // Function to toggle key generation sections visibility
        function toggleKeyGenerationSections() {
            const hasKey = currentKey !== null;
            const keyGenerationSection = document.getElementById('keyGenerationSection');
            const clearKeySection = document.getElementById('clearKeySection');
            
            if (hasKey) {
                // Hide key generation section, show clear button
                if (keyGenerationSection) keyGenerationSection.style.display = 'none';
                if (clearKeySection) clearKeySection.style.display = 'flex';
            } else {
                // Show key generation section, hide clear button
                if (keyGenerationSection) keyGenerationSection.style.display = 'block';
                if (clearKeySection) clearKeySection.style.display = 'none';
            }
        }

        // Function to clear current key
        function clearCurrentKey() {
            currentKey = null;
            currentMnemonic = null;
            currentPublicKey = null;
            currentDidKey = null;
            
            // Hide displays
            const didKeyDisplay = document.getElementById('didKeyDisplay');
            const mnemonicDisplay = document.getElementById('mnemonicDisplay');
            
            if (didKeyDisplay) didKeyDisplay.style.display = 'none';
            if (mnemonicDisplay) mnemonicDisplay.style.display = 'none';
            
            // Clear mnemonic input
            const mnemonicInput = document.getElementById('mnemonicInput');
            if (mnemonicInput) mnemonicInput.value = '';
            
            // Update UI
            toggleKeyGenerationSections();
            updateTabStates();
            updateSubmitButtonState();
            
            // Clear status
            const status = getCurrentStatusElement();
            if (status) status.innerHTML = '';
        }

        // DID:PLC form handling
        let currentPlcEntry = null;

        function createDidPlcEntry(formData) {
            const operation = {
                "type": "plc_operation",
                "rotationKeys": getRotationKeys(),
                "verificationMethods": {
                    "atproto": formData.atprotoVerificationMethod
                },
                "alsoKnownAs": getAlsoKnownAs(),
                "services": {
                    "atproto_pds": {
                        "type": "AtprotoPersonalDataServer",
                        "endpoint": formData.pdsEndpoint
                    }
                }
            };

            return operation;
        }

        function displayPlcResult(entry) {
            const resultDiv = document.getElementById('plc-result');
            const resultContent = document.getElementById('plc-result-content');
            
            if (resultContent) resultContent.textContent = JSON.stringify(entry, null, 2);
            if (resultDiv) resultDiv.style.display = 'block';
            
            // Scroll to result
            if (resultDiv) resultDiv.scrollIntoView({ behavior: 'smooth' });
        }

        async function copyPlcResult() {
            if (!currentPlcEntry) return;

            try {
                await navigator.clipboard.writeText(JSON.stringify(currentPlcEntry, null, 2));
                const status = getCurrentStatusElement();
                status.innerHTML = '<div class="status success">DID:PLC entry copied to clipboard!</div>';
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    if (status) {
                        status.innerHTML = '';
                    }
                }, 3000);
            } catch (error) {
                console.error('Error copying DID:PLC entry to clipboard:', error);
                const status = getCurrentStatusElement();
                status.innerHTML = '<div class="status error">Failed to copy DID:PLC entry to clipboard</div>';
            }
        }

        function clearPlcForm() {
            document.getElementById('didplc-form').reset();
            document.getElementById('plc-result').style.display = 'none';
            currentPlcEntry = null;
            const status = getCurrentStatusElement();
            if (status) {
                status.innerHTML = '';
            }
            
            // Reset rotation keys to single input
            const container = document.getElementById('rotation-keys-container');
            if (!container) return;
            container.innerHTML = '';
            
            const group = document.createElement('div');
            group.className = 'rotation-key-group';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'rotation-key-input';
            input.placeholder = 'Enter rotation key';
            input.required = true;
            
            // Add listener to update submit button state when rotation key changes
            input.addEventListener('input', function() {
                updateSubmitButtonState();
            });
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-rotation-key-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.style.display = 'none';
            removeBtn.addEventListener('click', function() {
                removeRotationKey(this);
            });
            
            group.appendChild(input);
            group.appendChild(removeBtn);
            container.appendChild(group);
            
            // Reset also known as to single input
            const alsoKnownAsContainer = document.getElementById('also-known-as-container');
            if (!alsoKnownAsContainer) return;
            alsoKnownAsContainer.innerHTML = '';
            
            const alsoKnownAsGroup = document.createElement('div');
            alsoKnownAsGroup.className = 'also-known-as-group';
            
            const alsoKnownAsInput = document.createElement('input');
            alsoKnownAsInput.type = 'text';
            alsoKnownAsInput.className = 'also-known-as-input';
            alsoKnownAsInput.placeholder = 'Enter alternative identifier (e.g., at://goat.navy)';
            
            const alsoKnownAsRemoveBtn = document.createElement('button');
            alsoKnownAsRemoveBtn.type = 'button';
            alsoKnownAsRemoveBtn.className = 'remove-also-known-as-btn';
            alsoKnownAsRemoveBtn.textContent = 'Remove';
            alsoKnownAsRemoveBtn.style.display = 'none';
            alsoKnownAsRemoveBtn.addEventListener('click', function() {
                removeAlsoKnownAs(this);
            });
            
            alsoKnownAsGroup.appendChild(alsoKnownAsInput);
            alsoKnownAsGroup.appendChild(alsoKnownAsRemoveBtn);
            alsoKnownAsContainer.appendChild(alsoKnownAsGroup);
        }
        
        function addRotationKey() {
            const container = document.getElementById('rotation-keys-container');
            const newGroup = document.createElement('div');
            newGroup.className = 'rotation-key-group';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'rotation-key-input';
            input.placeholder = 'Enter rotation key';
            input.required = true;
            
            // Add listener to update submit button state when rotation key changes
            input.addEventListener('input', function() {
                updateSubmitButtonState();
            });
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-rotation-key-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', function() {
                removeRotationKey(this);
            });
            
            newGroup.appendChild(input);
            newGroup.appendChild(removeBtn);
            container.appendChild(newGroup);
            
            // Show remove buttons if there are multiple inputs
            updateRemoveButtons();
        }
        
        function removeRotationKey(button) {
            const group = button.parentElement;
            const container = document.getElementById('rotation-keys-container');
            
            // Don't remove if it's the only input
            if (container.children.length > 1) {
                group.remove();
                updateRemoveButtons();
            }
        }
        
        function updateRemoveButtons() {
            const container = document.getElementById('rotation-keys-container');
            const removeButtons = container.querySelectorAll('.remove-rotation-key-btn');
            
            removeButtons.forEach(button => {
                button.style.display = container.children.length > 1 ? 'block' : 'none';
            });
        }
        
        function getRotationKeys() {
            const inputs = document.querySelectorAll('.rotation-key-input');
            return Array.from(inputs)
                .map(input => input.value.trim())
                .filter(value => value !== '');
        }
        
        function setRotationKeys(keys) {
            console.log('setRotationKeys called with:', keys);
            const container = document.getElementById('rotation-keys-container');
            console.log('Container found:', container);
            
            // Clear existing inputs
            if (!container) return;
            container.innerHTML = '';
            
            // Add inputs for each key
            keys.forEach((key, index) => {
                console.log(`Adding key ${index}:`, key);
                const group = document.createElement('div');
                group.className = 'rotation-key-group';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'rotation-key-input';
                input.placeholder = 'Enter rotation key';
                input.required = true;
                input.value = key;
                
                // Add listener to update submit button state when rotation key changes
                input.addEventListener('input', function() {
                    updateSubmitButtonState();
                });
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'remove-rotation-key-btn';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', function() {
                    removeRotationKey(this);
                });
                
                group.appendChild(input);
                group.appendChild(removeBtn);
                container.appendChild(group);
            });
            
            // If no keys, add one empty input
            if (keys.length === 0) {
                console.log('No keys provided, adding empty input');
                addRotationKey();
            }
            
            updateRemoveButtons();
            console.log('setRotationKeys completed');
        }
        
        function addAlsoKnownAs() {
            const container = document.getElementById('also-known-as-container');
            const newGroup = document.createElement('div');
            newGroup.className = 'also-known-as-group';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'also-known-as-input';
            input.placeholder = 'Enter alternative identifier (e.g., at://goat.navy)';
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'remove-also-known-as-btn';
            removeBtn.textContent = 'Remove';
            removeBtn.addEventListener('click', function() {
                removeAlsoKnownAs(this);
            });
            
            newGroup.appendChild(input);
            newGroup.appendChild(removeBtn);
            container.appendChild(newGroup);
            
            // Show remove buttons if there are multiple inputs
            updateAlsoKnownAsRemoveButtons();
        }
        
        function removeAlsoKnownAs(button) {
            const group = button.parentElement;
            const container = document.getElementById('also-known-as-container');
            
            // Don't remove if it's the only input
            if (container.children.length > 1) {
                group.remove();
                updateAlsoKnownAsRemoveButtons();
            }
        }
        
        function updateAlsoKnownAsRemoveButtons() {
            const container = document.getElementById('also-known-as-container');
            const removeButtons = container.querySelectorAll('.remove-also-known-as-btn');
            
            removeButtons.forEach(button => {
                button.style.display = container.children.length > 1 ? 'block' : 'none';
            });
        }
        
        function getAlsoKnownAs() {
            const inputs = document.querySelectorAll('.also-known-as-input');
            return Array.from(inputs)
                .map(input => input.value.trim())
                .filter(value => value !== '');
        }
        
        function setAlsoKnownAs(entries) {
            const container = document.getElementById('also-known-as-container');
            
            // Clear existing inputs
            if (!container) return;
            container.innerHTML = '';
            
            // Add inputs for each entry
            entries.forEach((entry, index) => {
                const group = document.createElement('div');
                group.className = 'also-known-as-group';
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'also-known-as-input';
                input.placeholder = 'Enter alternative identifier (e.g., at://goat.navy)';
                input.value = entry;
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'remove-also-known-as-btn';
                removeBtn.textContent = 'Remove';
                removeBtn.addEventListener('click', function() {
                    removeAlsoKnownAs(this);
                });
                
                group.appendChild(input);
                group.appendChild(removeBtn);
                container.appendChild(group);
            });
            
            // If no entries, add one empty input
            if (entries.length === 0) {
                addAlsoKnownAs();
            }
            
            updateAlsoKnownAsRemoveButtons();
        }

        // Add DID:PLC form event listeners
        const didplcForm = document.getElementById('didplc-form');
        if (didplcForm) {
            didplcForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const status = getCurrentStatusElement();
            
            // Check if a private key has been generated or loaded
            if (!currentKey) {
                if (status) {
                    status.innerHTML = '<div class="status error">No private key available! Please generate a new key or restore one from a mnemonic in the "Generate Key" tab first.</div>';
                }
                return;
            }
            
            const formData = new FormData(this);
            const data = Object.fromEntries(formData.entries());
            
            try {
                // Fetch the latest operation CID from the audit log
                const didPlcId = data.did;
                let prevCid = null;
                
                try {
                    const { auditLog } = await fetchDidPlcRecord(didPlcId);
                    if (auditLog && auditLog.length > 0) {
                        // Get the last operation's CID from the audit log
                        const lastRecord = auditLog[auditLog.length - 1];
                        prevCid = lastRecord.cid;
                        console.log('Previous CID:', prevCid);
                    }
                } catch (fetchError) {
                    console.log('Could not fetch audit log, assuming this is a creation operation');
                }
                
                // Create unsigned operation with prev field
                const unsignedOperation = createDidPlcEntry(data);
                if (prevCid) {
                    unsignedOperation.prev = prevCid;
                } else {
                    unsignedOperation.prev = null;
                }
                
                // Sign the operation
                const signedOperation = await signDidPlcOperation(unsignedOperation, currentKey);
                
                // Verify the signed operation
                console.log('Verifying signed operation...');
                const verificationResult = await verifyDidPlcOperation(signedOperation);
                
                console.log('Verification Result:', verificationResult);
                
                currentPlcEntry = signedOperation;
                displayPlcResult(currentPlcEntry);
                
                if (status) {
                    if (verificationResult.success && verificationResult.keysMatch) {
                        status.innerHTML = '<div class="status success">DID:PLC entry created, signed, and verified successfully! Submitting to plc.directory...</div>';
                        
                        // Submit to plc.directory after successful verification
                        try {
                            console.log('Submitting to plc.directory...');
                            const submitResult = await submitDidPlcOperation(signedOperation, didPlcId);
                            console.log('Submission result:', submitResult);
                            
                            if (submitResult.success) {
                                status.innerHTML = '<div class="status success">DID:PLC entry created, verified, and submitted to plc.directory successfully!</div>';
                            } else {
                                status.innerHTML = '<div class="status error">DID:PLC entry verified but submission to plc.directory failed. Check console for details.</div>';
                            }
                        } catch (submitError) {
                            console.error('Error submitting to plc.directory:', submitError);
                            status.innerHTML = '<div class="status error">DID:PLC entry verified but submission to plc.directory failed. Check console for details.</div>';
                        }
                    } else {
                        status.innerHTML = '<div class="status error">DID:PLC entry signed but verification failed. Check console for details.</div>';
                    }
                }
            } catch (error) {
                console.error('Error creating DID:PLC entry:', error);
                if (status) {
                    status.innerHTML = '<div class="status error">Error creating DID:PLC entry. Please check your input.</div>';
                }
            }
        });
        }

        const clearPlcBtn = document.getElementById('clear-plc-btn');
        const copyPlcResultBtn = document.getElementById('copy-plc-result-btn');
        const copyPlcDebugBtn = document.getElementById('copy-plc-debug-btn');
        
        if (clearPlcBtn) clearPlcBtn.addEventListener('click', clearPlcForm);
        if (copyPlcResultBtn) copyPlcResultBtn.addEventListener('click', copyPlcResult);
        if (copyPlcDebugBtn) copyPlcDebugBtn.addEventListener('click', copyPlcDebug);

        // Create Account form handling
        const createaccountForm = document.getElementById('createaccount-form');
        if (createaccountForm) {
            createaccountForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const status = getCurrentStatusElement();
            
            // Check if a private key has been generated or loaded
            if (!currentKey) {
                if (status) {
                    status.innerHTML = '<div class="status error">No private key available! Please generate a new key or restore one from a mnemonic in the "Generate Key" tab first.</div>';
                }
                return;
            }
            
            const formData = new FormData(this);
            const data = Object.fromEntries(formData.entries());
            
            try {
                // Call createAccount API with recoveryKey parameter
                if (status) {
                    status.innerHTML = '<div class="status success">Creating account on PDS...</div>';
                }
                
                console.log('Creating account with recovery key:', currentDidKey);
                
                const accountResult = await createAccount(
                    data.pdsEndpoint,
                    data.handle,
                    data.email,
                    data.password,
                    currentDidKey,
                    data.inviteCode
                );
                
                console.log('Account creation result:', accountResult);
                
                if (accountResult.success) {
                    // Update the DID:PLC field in the form with the returned DID
                    if (accountResult.result && accountResult.result.did) {
                        document.getElementById('account-did').value = accountResult.result.did;
                    }
                    
                    if (status) {
                        status.innerHTML = '<div class="status success">Account created successfully on PDS!</div>';
                    }
                } else {
                    throw new Error('Account creation failed');
                }
            } catch (error) {
                console.error('Error creating account:', error);
                if (status) {
                    status.innerHTML = '<div class="status error">Error creating account. Please check your input.</div>';
                }
            }
        });
        }

        const clearCreateaccountBtn = document.getElementById('clear-createaccount-btn');
        const copyCreateaccountResultBtn = document.getElementById('copy-createaccount-result-btn');
        
        if (clearCreateaccountBtn) {
            clearCreateaccountBtn.addEventListener('click', function() {
                const createaccountForm = document.getElementById('createaccount-form');
                const createaccountResult = document.getElementById('createaccount-result');
                if (createaccountForm) createaccountForm.reset();
                if (createaccountResult) createaccountResult.style.display = 'none';
                const status = getCurrentStatusElement();
                if (status) {
                    status.innerHTML = '';
                }
            });
        }

        if (copyCreateaccountResultBtn) {
            copyCreateaccountResultBtn.addEventListener('click', function() {
                // TODO: Implement copy functionality
                console.log('Copy account details clicked');
            });
        }

        // DID:PLC fetching functionality
        async function fetchDidPlcRecord(didPlc) {
            const url = `https://plc.directory/${didPlc}/log/audit`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const auditLog = await response.json();
                
                // Get the latest (current) record from the audit log
                if (auditLog.length === 0) {
                    throw new Error('No records found in audit log');
                }
                
                const latestRecord = auditLog[auditLog.length - 1];
                const operation = latestRecord.operation;
                
                // Extract the DID document data from the operation
                console.log('Latest record operation:', operation);
                console.log('Operation rotation keys:', operation.rotationKeys);
                
                const didDocument = {
                    id: latestRecord.did,
                    rotationKeys: operation.rotationKeys,
                    verificationMethods: operation.verificationMethods,
                    services: operation.services,
                    alsoKnownAs: operation.alsoKnownAs,
                    previousRotationKey: latestRecord.operation.prev
                };
                
                console.log('Extracted DID document:', didDocument);
                
                return { didDocument, auditLog };
            } catch (error) {
                console.error('Failed to fetch DID document:', error);
                throw error;
            }
        }

        function populateFormFromDidDocument(didDocument) {
            try {
                console.log('Received DID document:', didDocument);
                
                // Populate DID identifier
                if (didDocument.id) {
                    document.getElementById('plc-did').value = didDocument.id;
                    console.log('Set DID id:', didDocument.id);
                }

                // Populate rotation keys - check multiple possible field names
                let rotationKeys = didDocument.rotationKeys || didDocument.rotationKey || didDocument.rotation_keys || didDocument.rotation_keys_uri;
                let rotationKeyStrings = [];
                
                if (rotationKeys) {
                    console.log('Found rotation keys:', rotationKeys);
                    if (Array.isArray(rotationKeys)) {
                        // Handle array of objects or strings
                        rotationKeyStrings = rotationKeys.map(key => {
                            if (typeof key === 'object' && key !== null) {
                                // If it's an object, try to extract useful information
                                if (key.id) return key.id;
                                if (key.publicKeyMultibase) return key.publicKeyMultibase;
                                if (key.publicKey) return key.publicKey;
                                return JSON.stringify(key);
                            }
                            return key.toString();
                        });
                        console.log('Set rotation keys (array):', rotationKeyStrings);
                    } else {
                        rotationKeyStrings = [rotationKeys.toString()];
                        console.log('Set rotation keys (single):', rotationKeys);
                    }
                } else {
                    // Check if rotation keys are embedded in verification methods
                    if (didDocument.verificationMethod && Array.isArray(didDocument.verificationMethod)) {
                        const rotationKeyMethods = didDocument.verificationMethod.filter(method => 
                            method.type === 'EcdsaSecp256k1RecoveryMethod2020' || 
                            method.type === 'EcdsaSecp256k1VerificationKey2019' ||
                            method.purpose && method.purpose.includes('rotation')
                        );
                        if (rotationKeyMethods.length > 0) {
                            rotationKeyStrings = rotationKeyMethods.map(method => {
                                if (method.publicKeyMultibase) return method.publicKeyMultibase;
                                if (method.publicKey) return method.publicKey;
                                return JSON.stringify(method);
                            });
                            console.log('Set rotation keys from verification methods:', rotationKeyStrings);
                        }
                    }
                }
                
                // Set rotation keys using the new function
                console.log('About to set rotation keys:', rotationKeyStrings);
                setRotationKeys(rotationKeyStrings);

                // Populate ATProto verification method
                let verificationMethods = didDocument.verificationMethods || didDocument.verificationMethod || didDocument.verification_methods || didDocument.verification_method;
                if (verificationMethods) {
                    console.log('Found verification methods:', verificationMethods);
                    
                    if (typeof verificationMethods === 'object' && verificationMethods !== null) {
                        // Handle object format like {"atproto": "did:key:..."}
                        if (verificationMethods.atproto) {
                            document.getElementById('plc-atproto-verification-method').value = verificationMethods.atproto;
                            console.log('Set ATProto verification method:', verificationMethods.atproto);
                        } else {
                            console.log('No atproto key found in verification methods object');
                        }
                    } else if (Array.isArray(verificationMethods)) {
                        // Handle array format (fallback)
                        const methodStrings = verificationMethods.map(method => {
                            if (typeof method === 'object' && method !== null) {
                                if (method.id) return method.id;
                                if (method.type) return `${method.type}: ${method.publicKeyMultibase || method.publicKey || JSON.stringify(method)}`;
                                return JSON.stringify(method);
                            }
                            return method.toString();
                        });
                        // For arrays, take the first method as ATProto verification method
                        if (methodStrings.length > 0) {
                            document.getElementById('plc-atproto-verification-method').value = methodStrings[0];
                            console.log('Set ATProto verification method (from array):', methodStrings[0]);
                        }
                    } else {
                        // Handle string format (fallback)
                        document.getElementById('plc-atproto-verification-method').value = verificationMethods.toString();
                        console.log('Set ATProto verification method (string):', verificationMethods);
                    }
                }

                // Populate PDS endpoint
                let services = didDocument.services || didDocument.service || didDocument.service_endpoints;
                if (services) {
                    console.log('Found services:', services);
                    
                    if (typeof services === 'object' && services !== null) {
                        // Handle object format like {"atproto_pds": {"type": "AtprotoPersonalDataServer", "endpoint": "https://..."}}
                        if (services.atproto_pds && services.atproto_pds.endpoint) {
                            document.getElementById('plc-pds-endpoint').value = services.atproto_pds.endpoint;
                            console.log('Set PDS endpoint:', services.atproto_pds.endpoint);
                        } else {
                            console.log('No atproto_pds.endpoint found in services object');
                        }
                    } else if (Array.isArray(services)) {
                        // Handle array format (fallback)
                        const serviceStrings = services.map(service => {
                            if (typeof service === 'object' && service !== null) {
                                if (service.id) return service.id;
                                if (service.type && service.serviceEndpoint) return `${service.type}: ${service.serviceEndpoint}`;
                                return JSON.stringify(service);
                            }
                            return service.toString();
                        });
                        // For arrays, take the first service as PDS endpoint
                        if (serviceStrings.length > 0) {
                            document.getElementById('plc-pds-endpoint').value = serviceStrings[0];
                            console.log('Set PDS endpoint (from array):', serviceStrings[0]);
                        }
                    } else {
                        // Handle string format (fallback)
                        document.getElementById('plc-pds-endpoint').value = services.toString();
                        console.log('Set PDS endpoint (string):', services);
                    }
                }

                // Populate also known as
                if (didDocument.alsoKnownAs && Array.isArray(didDocument.alsoKnownAs)) {
                    setAlsoKnownAs(didDocument.alsoKnownAs);
                    console.log('Set alsoKnownAs:', didDocument.alsoKnownAs);
                } else {
                    // If no alsoKnownAs or not an array, set empty
                    setAlsoKnownAs([]);
                    console.log('No alsoKnownAs found or not an array');
                }

                // Populate previous update
                let previousUpdate = didDocument.previousRotationKey || didDocument.previous_rotation_key || didDocument.previousUpdate;
                if (previousUpdate) {
                    document.getElementById('plc-previous-update').value = previousUpdate;
                    console.log('Set previous update:', previousUpdate);
                }

                return true;
            } catch (error) {
                console.error('Error populating form:', error);
                return false;
            }
        }

        // Check if the loaded key matches any of the rotation keys in the form
        function checkKeyMatchesRotationKeys(rotationKeysArray) {
            try {
                // Get the current DID key
                if (!currentDidKey) {
                    console.log('No key loaded');
                    return false;
                }
                
                // If rotation keys array is provided, use that; otherwise get from form
                let rotationKeys;
                if (rotationKeysArray && Array.isArray(rotationKeysArray)) {
                    rotationKeys = rotationKeysArray;
                } else {
                    // Fallback: get from form inputs
                    const rotationKeyInputs = document.querySelectorAll('.rotation-key-input');
                    rotationKeys = Array.from(rotationKeyInputs).map(input => input.value.trim()).filter(val => val);
                }
                
                console.log('Checking if loaded key matches rotation keys...');
                console.log('Loaded key:', currentDidKey);
                console.log('Rotation keys:', rotationKeys);
                
                // Check if currentDidKey matches any rotation key
                const matches = rotationKeys.includes(currentDidKey);
                
                console.log('Key matches:', matches);
                
                return matches;
            } catch (error) {
                console.error('Error checking key match:', error);
                return false;
            }
        }

        // Update the submit button state based on whether the loaded key matches
        function updateSubmitButtonState() {
            try {
                const submitBtn = document.getElementById('submit-plc-btn');
                if (!submitBtn) {
                    // Not on the DID:PLC Entry tab
                    return;
                }
                
                const keyMatches = checkKeyMatchesRotationKeys();
                
                if (!keyMatches) {
                    if (submitBtn) submitBtn.disabled = true;
                    if (submitBtn) submitBtn.title = 'Load a matching rotation key to enable updates';
                } else {
                    if (submitBtn) submitBtn.disabled = false;
                    if (submitBtn) submitBtn.title = '';
                }
            } catch (error) {
                console.error('Error updating submit button state:', error);
            }
        }

        async function handleFetchDidRecord() {
            const didInput = document.getElementById('plc-did');
            const fetchBtn = document.getElementById('fetch-did-btn');
            const status = getCurrentStatusElement();
            
            const didPlc = didInput.value.trim();
            
            if (!didPlc) {
                status.innerHTML = '<div class="status error">Please enter a DID:PLC address first</div>';
                return;
            }

            if (!didPlc.startsWith('did:plc:')) {
                status.innerHTML = '<div class="status error">Please enter a valid DID:PLC address (must start with "did:plc:")</div>';
                return;
            }

            // Show loading state
            if (fetchBtn) fetchBtn.disabled = true;
            if (fetchBtn) fetchBtn.textContent = 'Fetching...';
            if (status) status.innerHTML = '<div class="status success">Fetching DID:PLC record from plc.directory...</div>';

            try {
                const { didDocument, auditLog } = await fetchDidPlcRecord(didPlc);
                
                // Show raw audit log for debugging
                const debugDiv = document.getElementById('plc-debug');
                const debugContent = document.getElementById('plc-debug-content');
                debugContent.textContent = JSON.stringify(auditLog, null, 2);
                debugDiv.style.display = 'block';
                
                if (populateFormFromDidDocument(didDocument)) {
                    status.innerHTML = '<div class="status success">DID:PLC record fetched and form populated successfully!</div>';
                } else {
                    status.innerHTML = '<div class="status error">Record fetched but some fields could not be populated</div>';
                }
                
                // Extract rotation keys from the fetched DID document
                let rotationKeys = didDocument.rotationKeys || didDocument.rotationKey || didDocument.rotation_keys || didDocument.rotation_keys_uri;
                let rotationKeyStrings = [];
                
                if (rotationKeys) {
                    if (Array.isArray(rotationKeys)) {
                        rotationKeyStrings = rotationKeys.map(key => {
                            if (typeof key === 'object' && key !== null) {
                                if (key.id) return key.id;
                                if (key.publicKeyMultibase) return key.publicKeyMultibase;
                                if (key.publicKey) return key.publicKey;
                                return JSON.stringify(key);
                            }
                            return key.toString();
                        });
                    } else {
                        rotationKeyStrings = [rotationKeys.toString()];
                    }
                }
                
                console.log('Checking key against fetched DID document rotation keys:', rotationKeyStrings);
                
                // Check if the loaded key matches any rotation keys from the fetched record
                const submitBtn = document.getElementById('submit-plc-btn');
                const keyMatches = checkKeyMatchesRotationKeys(rotationKeyStrings);
                
                if (!keyMatches) {
                    if (status) status.innerHTML = '<div class="status error">WARNING: The loaded private key does NOT match any rotation keys in this DID:PLC record. Updates cannot be signed with this key.</div>';
                    if (submitBtn) submitBtn.disabled = true;
                    if (submitBtn) submitBtn.title = 'Load a matching rotation key to enable updates';
                } else {
                    if (status) status.innerHTML = '<div class="status success">DID:PLC record fetched and form populated successfully! Key matches rotation keys.</div>';
                    if (submitBtn) submitBtn.disabled = false;
                    if (submitBtn) submitBtn.title = '';
                }
                
                // Clear any existing result
                document.getElementById('plc-result').style.display = 'none';
                currentPlcEntry = null;
                
            } catch (error) {
                console.error('Error fetching DID:PLC record:', error);
                status.innerHTML = `<div class="status error">Failed to fetch DID:PLC record: ${error.message}</div>`;
                
                // Hide debug section on error
                document.getElementById('plc-debug').style.display = 'none';
            } finally {
                // Reset button state
                if (fetchBtn) fetchBtn.disabled = false;
                if (fetchBtn) fetchBtn.textContent = 'Fetch Record';
            }
        }

        async function handleVerifyDidCreation() {
            const didInput = document.getElementById('plc-did');
            const verifyBtn = document.getElementById('verify-did-btn');
            const status = getCurrentStatusElement();
            
            const didPlc = didInput.value.trim();
            
            if (!didPlc) {
                status.innerHTML = '<div class="status error">Please enter a DID:PLC address first</div>';
                return;
            }

            if (!didPlc.startsWith('did:plc:')) {
                status.innerHTML = '<div class="status error">Please enter a valid DID:PLC address (must start with "did:plc:")</div>';
                return;
            }

            // Show loading state
            if (verifyBtn) verifyBtn.disabled = true;
            if (verifyBtn) verifyBtn.textContent = 'Verifying...';
            if (status) status.innerHTML = '<div class="status success">Verifying DID:PLC creation record...</div>';

            try {
                console.log('=== Verifying DID:PLC Creation ===');
                console.log('DID:PLC:', didPlc);
                
                // Fetch the audit log to get the initial creation record
                const { auditLog } = await fetchDidPlcRecord(didPlc);
                
                if (auditLog.length === 0) {
                    throw new Error('No records found in audit log');
                }
                
                // Get the first (creation) record
                const creationRecord = auditLog[0];
                console.log('Creation record:', creationRecord);
                
                const operation = creationRecord.operation;
                console.log('Creation operation:', operation);
                
                // Verify the operation using our verification function
                console.log('=== Verifying Operation ===');
                const verificationResult = await verifyDidPlcOperation(operation);
                
                // Generate DID:PLC ID from the signed operation
                console.log('=== Generating DID:PLC ID ===');
                const generatedDidPlcId = await generateDidPlcId(operation);
                console.log('Generated DID:PLC ID:', generatedDidPlcId);
                
                // Compare with the actual DID
                const actualDid = creationRecord.did;
                const didMatch = generatedDidPlcId === actualDid;
                
                console.log('=== Verification Results ===');
                console.log('Actual DID:', actualDid);
                console.log('Generated DID:', generatedDidPlcId);
                console.log('DID Match:', didMatch ? 'MATCH' : 'NO MATCH');
                console.log('Verification Result:', verificationResult);
                
                const signatureValid = verificationResult.success;
                const keysMatch = verificationResult.keysMatch;
                
                console.log('Signature Valid:', signatureValid ? 'YES' : 'NO');
                console.log('Keys Match:', keysMatch ? 'YES' : 'NO');
                
                // Display results
                let resultHtml = '<div class="verification-results">';
                resultHtml += '<h4>Verification Results</h4>';
                resultHtml += '<div class="verification-item">';
                resultHtml += `<strong>Actual DID:</strong> <code>${actualDid}</code><br>`;
                resultHtml += `<strong>Generated DID:</strong> <code>${generatedDidPlcId}</code><br>`;
                resultHtml += `<strong>DID Match:</strong> ${didMatch ? 'Yes' : 'No'}<br>`;
                resultHtml += `<strong>Signature Valid:</strong> ${signatureValid ? 'Yes' : 'No'}<br>`;
                resultHtml += `<strong>Keys Match:</strong> ${keysMatch ? 'Yes' : 'No'}`;
                
                if (verificationResult.recoveredDidKey) {
                    resultHtml += `<br><strong>Recovered DID:key:</strong> <code>${verificationResult.recoveredDidKey}</code>`;
                }
                if (verificationResult.operationRotationKey) {
                    resultHtml += `<br><strong>Operation DID:key:</strong> <code>${verificationResult.operationRotationKey}</code>`;
                }
                
                resultHtml += '</div>';
                
                if (didMatch && signatureValid && keysMatch) {
                    resultHtml += '<div class="status success">🎉 Verification successful! Both DID:PLC ID generation and signature verification are working correctly.</div>';
                } else {
                    resultHtml += '<div class="status error">Verification failed. Check console for detailed debugging information.</div>';
                }
                
                resultHtml += '</div>';
                
                status.innerHTML = resultHtml;
                
            } catch (error) {
                console.error('Error verifying DID:PLC creation:', error);
                status.innerHTML = `<div class="status error">Failed to verify DID:PLC creation: ${error.message}</div>`;
            } finally {
                // Reset button state
                if (verifyBtn) verifyBtn.disabled = false;
                if (verifyBtn) verifyBtn.textContent = 'Verify Creation';
            }
        }

        async function handleReserveKey() {
            const didInput = document.getElementById('plc-did');
            const pdsInput = document.getElementById('plc-pds-endpoint');
            const reserveBtn = document.getElementById('reserve-key-btn');
            const status = getCurrentStatusElement();
            
            const didPlc = didInput.value.trim();
            const pdsEndpoint = pdsInput.value.trim();
            
            if (!didPlc) {
                status.innerHTML = '<div class="status error">Please enter a DID:PLC address first</div>';
                return;
            }

            if (!didPlc.startsWith('did:plc:')) {
                status.innerHTML = '<div class="status error">Please enter a valid DID:PLC address (must start with "did:plc:")</div>';
                return;
            }

            if (!pdsEndpoint) {
                status.innerHTML = '<div class="status error">Please enter a PDS endpoint</div>';
                return;
            }

            // Show loading state
            if (reserveBtn) reserveBtn.disabled = true;
            if (reserveBtn) reserveBtn.textContent = 'Reserving...';
            if (status) status.innerHTML = '<div class="status success">Reserving signing key on PDS...</div>';

            try {
                console.log('=== Reserving Signing Key ===');
                console.log('DID:PLC:', didPlc);
                console.log('PDS Endpoint:', pdsEndpoint);
                
                const reserveResult = await reserveSigningKey(pdsEndpoint, didPlc);
                console.log('Reservation result:', reserveResult);
                
                if (reserveResult.success && reserveResult.result && reserveResult.result.signingKey) {
                    // Update the ATProto verification method field with the returned key
                    document.getElementById('plc-atproto-verification-method').value = reserveResult.result.signingKey;
                    status.innerHTML = '<div class="status success">Signing key reserved successfully! Key updated in form.</div>';
                } else {
                    status.innerHTML = '<div class="status error">Key reservation succeeded but no signing key returned</div>';
                }
                
            } catch (error) {
                console.error('Error reserving signing key:', error);
                status.innerHTML = `<div class="status error">Failed to reserve signing key: ${error.message}</div>`;
            } finally {
                // Reset button state
                if (reserveBtn) reserveBtn.disabled = false;
                if (reserveBtn) reserveBtn.textContent = 'Reserve Key';
            }
        }

        async function copyPlcDebug() {
            const debugContent = document.getElementById('plc-debug-content');
            if (!debugContent.textContent) return;

            try {
                await navigator.clipboard.writeText(debugContent.textContent);
                const status = getCurrentStatusElement();
                status.innerHTML = '<div class="status success">Raw DID document copied to clipboard!</div>';
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    if (status) {
                        status.innerHTML = '';
                    }
                }, 3000);
            } catch (error) {
                console.error('Error copying raw DID document to clipboard:', error);
                const status = getCurrentStatusElement();
                status.innerHTML = '<div class="status error">Failed to copy raw DID document to clipboard</div>';
            }
        }

        // Add event listener for fetch button
        const fetchDidBtn = document.getElementById('fetch-did-btn');
        if (fetchDidBtn) fetchDidBtn.addEventListener('click', handleFetchDidRecord);
        
        // Add event listener for verify button
        const verifyDidBtn = document.getElementById('verify-did-btn');
        if (verifyDidBtn) verifyDidBtn.addEventListener('click', handleVerifyDidCreation);
        
        // Add event listener for reserve key button
        const reserveKeyBtn = document.getElementById('reserve-key-btn');
        if (reserveKeyBtn) reserveKeyBtn.addEventListener('click', handleReserveKey);
        
        // Add event listeners for rotation key buttons
        const addRotationKeyBtn = document.getElementById('add-rotation-key-btn');
        if (addRotationKeyBtn) addRotationKeyBtn.addEventListener('click', addRotationKey);
        
        // Add event listener for the initial remove button
        const initialRemoveBtn = document.querySelector('.remove-rotation-key-btn');
        if (initialRemoveBtn) {
            initialRemoveBtn.addEventListener('click', function() {
                removeRotationKey(this);
            });
        }
        
        // Add event listeners for also known as buttons
        const addAlsoKnownAsBtn = document.getElementById('add-also-known-as-btn');
        if (addAlsoKnownAsBtn) addAlsoKnownAsBtn.addEventListener('click', addAlsoKnownAs);
        
        // Add event listener for the initial also known as remove button
        const initialAlsoKnownAsRemoveBtn = document.querySelector('.remove-also-known-as-btn');
        if (initialAlsoKnownAsRemoveBtn) {
            initialAlsoKnownAsRemoveBtn.addEventListener('click', function() {
                removeAlsoKnownAs(this);
            });
        }

        // Check if Web Crypto API is available
        if (!window.crypto || !window.crypto.getRandomValues) {
            const keyDisplay = document.getElementById('keyDisplay');
            const generateBtn = document.getElementById('generateBtn');
            if (keyDisplay) keyDisplay.textContent = 'Web Crypto API not supported in this browser';
            if (generateBtn) generateBtn.disabled = true;
        }

        // Run test case on page load
        testDidPlcIdGeneration();
    </script>
</body>
</html>
